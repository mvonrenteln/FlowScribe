# Tags System

This document describes the Tag model, validation and operational contracts used by the TranscriptEditor and related UI. It documents the current decisions, expected behavior, and migration guidance.

## Key Decisions

- Identity: `Tag.id` is the canonical identity for a Tag. `Tag.name` is a mutable attribute used only for display. `Tag.id` is a UUID generated by the client on creation.
- Session scope: Tags are stored per-session. They live on `PersistedSession.tags` and are not global configuration. `Segment.tags` contains an array of `string` Tag IDs which reference `Tag.id` in the current session.
- Validation policy: The store enforces the following rules:
  - Tag names are trimmed (`trim()`) before validation and storage.
  - Empty or whitespace-only names are rejected.
  - Duplicate names within the same session are rejected (case-insensitive after trimming).
  - On validation failure, the store operation returns `false` and does not mutate state.

## API contracts

- `addTag(name: string): boolean` â€” attempts to create a new tag with the given name. Returns `true` when tag was created, `false` when validation fails (duplicate/empty). On success a new `Tag` with `id` is appended to `PersistedSession.tags` and a history snapshot is created.
- `renameTag(tagId: string, newName: string): boolean` â€” attempts to rename an existing tag. Returns `true` on success, `false` on validation failure or if `tagId` does not exist. `Tag.id` remains stable.
- `removeTag(tagId: string): void` â€” removes a Tag by id and removes the id from all `Segment.tags` in the current session. This operation creates a history snapshot.
- Assignment APIs (`assignTagToSegment`, `removeTagFromSegment`, `toggleTagOnSegment`) all operate with `Tag.id` and update `Segment.tags: string[]`.

Notes for UI authors
- Components that call `addTag` / `renameTag` should check the boolean return and present inline validation feedback when `false` is returned (e.g. keep the dialog open and show a field-level error + highlight).
- Components that only assign an existing tag to a segment should use the assignment API that accepts `tagId` (not `addTag`).

## Why `Tag.id` vs `Tag.name`

Using stable IDs decouples the user's ability to rename tags from references in segments and history. It simplifies rename operations (only `Tag.name` changes, `Segment.tags` need no remapping) and avoids ambiguity when multiple sessions are merged or when history snapshots are restored.

## When duplicate tags can actually occur

In the normal single-session editor flow duplicates should not occur because the store refuses to create them. The remaining cases where duplicates might exist are:

- Importing older sessions or transcripts produced by external tools that did not enforce the current validation rules.
- Merging multiple persisted sessions together (import/multi-session workflows) where each session had its own independent tag set and names may collide.
- Manual corruption of persisted session JSON.

If your project does not import or merge sessions from external sources, duplicates are unlikely and a migration may be unnecessary.

## Migration guidance (when needed)

If you introduce stricter validation or change the Tag model, consider these steps when loading persisted sessions:

1. Run a `normalizeTags(session)` pass that:
   - Trims and normalizes tag names (e.g. collapse multiple spaces) and computes a canonical form (lowercased) for duplicate detection.
   - Builds a map of canonical name -> surviving Tag.id (keep-first or merge rule as desired).
   - Remaps `Segment.tags` arrays from any replaced ids to the surviving Tag.id.
   - Removes duplicate `Tag` objects from `PersistedSession.tags`.

2. Create a migration test that loads sample legacy sessions and asserts the normalized state.

3. When merging sessions, prefer an explicit merge UI or deterministic merge strategy (e.g. first seen wins, or prompt user to resolve duplicates).

## Tests & Enforcement

- Unit tests should assert the boolean return value of `addTag` and `renameTag` (successful + failing cases). This guards against regressions where validation could be bypassed.
- The store tests should remain the source of truth for validation semantics; UI tests should check that UI correctly shows errors and that the dialog remains open when `addTag` / `renameTag` return `false`.

## Summary

- `Tag.id` is canonical and stable.
- Tags are session-local and referenced by id in segments.
- Store enforces trimming, non-empty, and duplicate-name rejection; API returns boolean to indicate success/failure.
- Migration only needed for imports/merges or old persisted sessions; otherwise not required.

If you want, I can also add a small `tagMigration` utility and a sample test that demonstrates a migration from a legacy session with duplicate names.
# Tags System - Feature Concept

## Overview

The Tags System extends FlowScribe with a flexible, fine-grained annotation system. Tags are category-agnostic labels that can be applied to segments in addition to speakers. They function analogously to speakers (colors, editing, filtering) but are semantically independent and orthogonal to the speaker concept.

**Core Characteristics:**
- Independent of speakers (1:1 parallel hierarchy)
- Multiple tags per segment possible (rare but supported)
- Color-coded like speakers
- Keyboard-first assignment (keys 1â€“0 + T for manual tag mode)
- Editable, mergeable, renameable, deletable
- Simple single/double-click filter logic (positive â†’ negative/NOT)

---

## Architecture

### Type Definitions

```typescript
// client/src/lib/store/types.ts

export interface Tag {
  id: string;
  name: string;
  color: string;
}

// Update Segment
export interface Segment {
  id: string;
  speaker: string;
  tags: string[];  // â† NEW: Tag names or IDs (prefer names for consistency with speaker)
  start: number;
  end: number;
  text: string;
  words: Word[];
  confirmed?: boolean;
  bookmarked?: boolean;
}
```

### Store Slices

**New Slice: `tagsSlice.ts`**
```typescript
export interface TagsSlice {
  tags: Tag[];
  
  // Mutations
  addTag: (name: string) => void;
  renameTag: (oldName: string, newName: string) => void;
  mergeTag: (fromName: string, toName: string) => void;
  deleteTag: (name: string) => void;
  assignTagToSegment: (segmentId: string, tagName: string) => void;
  removeTagFromSegment: (segmentId: string, tagName: string) => void;
  
  // Utility
  getSegmentsWithTag: (tagName: string) => Segment[];
  getSegmentsWithoutTag: (tagName: string) => Segment[];
  getTagColor: (tagName: string) => string;
}
```

**Extend: `store/types.ts` â†’ `FilterState`**
```typescript
export interface FilterState {
  speakers: string[];          // Speaker filter (existing)
  tags: string[];              // NEW: Positive tag filters (include)
  tagsExcluded: string[];      // NEW: Negative tag filters (exclude/NOT)
  showNoTags?: boolean;        // NEW: Show only segments with NO tags
}

// Conceptually:
// Displayed segments = (segment.speaker in speakers) 
//                    AND (tags.length === 0 OR segment.tags.some(t => tags.includes(t)))
//                    AND (segment.tags.every(t => !tagsExcluded.includes(t)))
//                    AND (showNoTags ? segment.tags.length === 0 : true)
```

### Persistence

**Sessions extend to include tags:**
```typescript
export interface PersistedSession {
  // ... existing
  tags: Tag[];                 // â† NEW
  // Segments now include tags field
}
```

---

## UI Layout

### Left Sidebar: Speaker & Tags Sections

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         File: demo.mp3                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ [Search/Filter Input]                   â”‚
â”‚                                         â”‚
â”‚ ðŸ” Speakers                      â–¼      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚â”‚ âŠ  Alice                    (12 seg)   â”‚â”‚
â”‚â”‚ âŠ  Bob                      (8 seg)    â”‚â”‚
â”‚â”‚ âŠ  Narrator                 (5 seg)    â”‚â”‚
â”‚â”‚ âŠž [+ Add Speaker]                    â”‚â”‚
â”‚â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚                                         â”‚ â† ScrollArea (Speaker section)
â”‚                                         â”‚
â”‚ ðŸ“Œ Tags                           â–¼     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚â”‚ â˜ OOC              (4 seg)     â‹®      â”‚â”‚ â† Right-click/dbl-click for NOT
â”‚â”‚ â˜ EDIT             (7 seg)     â‹®      â”‚â”‚    (context menu or toggle)
â”‚â”‚ â˜ FX               (2 seg)     â‹®      â”‚â”‚
â”‚â”‚ â˜ No Tags          (3 seg)     â‹®      â”‚â”‚
â”‚â”‚ âŠž [+ Add Tag]                        â”‚â”‚
â”‚â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚                                         â”‚ â† ScrollArea (Tags section)
â”‚                                         â”‚
â”‚ âš™ Other Filters                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚â”‚ â˜ Bookmarks                (5 seg)   â”‚â”‚
â”‚â”‚ â˜ Low Confidence           (8 seg)   â”‚â”‚
â”‚â”‚ â˜ Spelling Issues          (12 seg)  â”‚â”‚
â”‚â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Key Points:**
- Separate scrollable areas for speakers and tags (prevents one from pushing out the other)
- Clear visual separation (icons: ðŸ” vs ðŸ“Œ)
- Consistent checkbox UI as existing filters
- "No Tags" filter appears as special item in the tags section
- Right-click/double-click on tag shows context menu with "Exclude (NOT)" option

### Tag Filter Context Menu

```
Right-click on "OOC" tag:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ âŠ• Include (OOC)         â”‚ â† Single-click does this by default
â”‚ âŠ– Exclude (NOT OOC)     â”‚ â† Double-click or right-click â†’ this
â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
â”‚ Rename                  â”‚
â”‚ Merge Into...           â”‚
â”‚ Delete                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Visual Indicator:
- â˜ OOC (not selected)
- âŠ• OOC (included/selected)
- âŠ– OOC (excluded/NOT - different icon, e.g., strikethrough or X)
```

### Segment Card: Tag Display

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  00:42â€“00:58 | Alice  [EDIT] [FX]       ...  â”‚
â”‚                                              â”‚
â”‚  And then we noticed the problem...         â”‚
â”‚                                              â”‚
â”‚  Tags: [EDIT]âœ• [FX]âœ• [+ Add]       â–¼      â”‚ â† NEW: inline tag mgmt
â”‚                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Context Menu (...):
â”œâ”€ Change Speaker
â”œâ”€ Split Segment
â”œâ”€ Manage Tags â”€â”€â”€â”€â”€â”€â”
â”‚                    â””â”€ Quick tag picker (list of all tags)
â”œâ”€ Merge...
â””â”€ Delete
```

---

## Filter Interaction Model

### Click Behavior

**Single-click:**
- Toggle tag in include filter (`tags` array)
- Visual: â˜ â†’ âŠ• (or vice versa, unmarked â†’ checked)
- Effect: Show segments with this tag

**Double-click or right-click:**
- Open context menu
- Select "Exclude (NOT)" â†’ toggle tag in exclude filter (`tagsExcluded` array)
- Visual: âŠ• OOC â†’ âŠ– OOC (e.g., strikethrough or different icon)
- Effect: Hide segments with this tag

### Filter Logic

```
User clicks:        â†’ Filter State          â†’ Result
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Single "OOC"        â†’ tags: ["OOC"]         â†’ All OOC segments
Single "OOC" + "FX" â†’ tags: ["OOC", "FX"]   â†’ OOC OR FX segments
Single "Alice"      â†’ speakers: ["Alice"]   â†’ All Alice segments
Alice + OOC         â†’ speakers: ["Alice"],  â†’ Alice AND OOC
                      tags: ["OOC"]

Dbl-click OOC       â†’ tagsExcluded: ["OOC"] â†’ All segments EXCEPT OOC
Alice + NOT OOC     â†’ speakers: ["Alice"],  â†’ Alice segments without OOC
                      tagsExcluded: ["OOC"]

"No Tags"           â†’ showNoTags: true      â†’ Only untagged segments
```

### Common Workflows

```
1. Review all OOC sections:
   â†’ Single-click "OOC" tag
   â†’ Display: All segments with OOC tag

2. Prepare Alice content for summarization (exclude OOC):
   â†’ Single-click "Alice" (speaker)
   â†’ Double-click "OOC" tag (to exclude)
   â†’ Display: Alice segments without OOC

3. Find untagged content:
   â†’ Single-click "No Tags" filter
   â†’ Display: All segments with empty tags array

4. Quick multi-tag filter (OR within tags):
   â†’ Single-click "EDIT" tag
   â†’ Single-click "REVIEW" tag
   â†’ Display: Segments with EDIT OR REVIEW
   â†’ (Note: NOT "EDIT AND REVIEW" â€” tags use OR logic, consistent with speakers)
```

---

## Keyboard Shortcuts

### Tag Assignment (Keyboard-First)

```
T + 1         â†’  Assign Tag #1 (toggle)
T + 2         â†’  Assign Tag #2 (toggle)
T + 3â€“9       â†’  Assign Tag #3â€“#9
T + 0         â†’  Assign Tag #10

Behavior:
- If tag already on current segment â†’ remove it
- If not â†’ add it
- Works on single selection (current segment)
- Works on range selections (apply tag to all selected segments)
- Each segment: toggle independently

Examples:
- Current segment has OOC (Tag #1) â†’ T+1 â†’ removed
- Current segment has no OOC â†’ T+1 â†’ added

### Alternative: Manual Tag Entry (if needed)

```
Cmd+T or Ctrl+T  â†’  Open "Add Tag" dialog
                     â†’ Type tag name
                     â†’ Tab-complete existing tags
                     â†’ Assign to current segment
                     (fallback if keyboard shortcut slot exhausted)
```

---

## Implementation Roadmap

### Phase 1: MVP - Complete Usable Feature (2â€“3 PRs)

**Goal:** Fully functional tag system with keyboard-first assignment, sidebar display (positive filters only), and segment badge display. No NOT-filter logic yet.

1. **Core data model & store**
   - Update `Segment` interface with `tags: string[]`
   - Create `tagsSlice.ts` with CRUD operations: `addTag()`, `assignTagToSegment()`, `removeTagFromSegment()`, etc.
   - Extend `FilterState` with `tags: string[]` (positive filter only)
   - Update persistence (sessions include tags array)
   - Tag color assignment (cycle through SPEAKER_COLORS palette)
   - History integration (all mutations use addToHistory)

2. **Sidebar UI - positive filtering only**
   - Refactor `SpeakerSidebar` into two scrollable sections: Speakers + Tags
   - Tag list rendering with segment counts
   - Single-click toggle for include filter (positive tags)
   - Visual indicator: without background (unmarked), with background (included)
   - Update `selectFilteredSegments()` predicate for positive tag filtering
   - (NO context menu, NO double-click yet)

3. **Keyboard-driven assignment**
   - Implement T+1...0 keyboard shortcuts
   - Toggle tag on current segment (or range selection)
   - Each segment toggles independently
   - Integration with selection/navigation hooks
   - Tests for keyboard interactions

4. **Segment card integration**
   - Display tags inline as badges on segment cards
   - Add âœ• button to remove each tag from segment
   - Add "+ Add Tag" quick picker button (UI-based tag assignment)
   - All inline operations work without context menu

### Phase 2: Tag Management & Advanced Keyboard (1â€“2 PRs)

**Goal:** Complete keyboard-driven management and additional UI conveniences.

2. **Tag sidebar management UI**
   - Rename, delete operations (similar to speaker sidebar)
   - Add speaker alongside "Add Tag" button

3. **Enhanced segment UI**
   - Tag picker: searchable list of available tags

4. **"No Tags" filter**
   - Add "No Tags" as special item in tags section
   - Single-click toggle for `showNoTags` state

### Phase 3: Complex Filter Logic (1 PR)

**Goal:** NOT-filters and advanced filter combinations.

1. **Exclude (NOT) filter support**
   - Extend `FilterState` with `tagsExcluded: string[]`
   - Visual indicator: âŠ– (excluded/NOT)

2. **Filter predicate updates**
   - Update `selectFilteredSegments()` with NOT logic
   - Correct AND/NOT combination with speaker filters
   - Test all filter combinations

3. **Export**
   - Export: include tags in JSON/Whisper-X output

---

## Design Consistency

### âœ“ Store Patterns
- New `tagsSlice` mirrors `speakersSlice` structure
- Immutable updates via Zustand setter
- History integration (addToHistory on all mutations)

### âœ“ Filter Integration
- Reuses existing `FilterState` mechanism
- Extends cleanly with `tags` and `tagsExcluded` (additive, non-breaking)
- Consistent selector pattern (`selectFilteredSegments` updated)

### âœ“ UI Consistency
- Tag cards/items match speaker card design in sidebar
- Same color palette + cycle logic (SPEAKER_COLORS)
- Badges/pills match existing shadcn/ui components
- Keyboard shortcut pattern analogous to speakers

### âœ“ Data Persistence
- Sessions extend naturally (new `tags` field, new `tags` array on segments)
- Backward-compatible: existing sessions without tags load with `tags: []`
- Export format includes tags (JSON and Whisper-X parity)

### âœ“ AI Infrastructure
- Tags compatible with existing AI feature pipelines (lib/ai/*)
- Can be used as selection criteria in batch operations
- No changes to core AI types (tags are metadata annotations)

---

## Testing Strategy

### Unit Tests

1. **tagsSlice**
   - `addTag()` â†’ new tag with auto-color
   - `renameTag()` â†’ updates all segment references
   - `mergeTag()` â†’ migrates segments, deletes source
   - `assignTagToSegment()` â†’ idempotent (no duplicates)
   - `removeTagFromSegment()` â†’ safe if tag not present

2. **Filter predicates**
   - Positive filter (include tags): OR logic
   - Negative filter (exclude tags): NOT logic
   - Combined speaker + tags: AND logic
   - "no tags" filter: tag array empty

3. **Selectors**
   - `selectFilteredSegments()` with tag filters
   - `selectAvailableTags()` based on current segments

### Integration Tests

1. **Store integration**
   - Tag operations trigger history updates
   - Undo/redo with tags works correctly
   - Tag persistence in sessions survives reload

2. **UI component tests**
   - Tag sidebar renders correctly
   - Tag assignment keyboard shortcuts work
   - Filter toggles update displayed segments

---

## Testing Strategy

### Unit Tests

1. **tagsSlice**
   - `addTag()` â†’ new tag with auto-color
   - `renameTag()` â†’ updates all segment references
   - `mergeTag()` â†’ migrates segments, deletes source
   - `assignTagToSegment()` â†’ idempotent (no duplicates)
   - `removeTagFromSegment()` â†’ safe if tag not present

2. **Filter predicates**
   - Positive filter (include tags): OR logic
   - Negative filter (exclude tags): NOT logic (correct negation)
   - Combined speaker + tags: AND between speaker & tag filters
   - "No Tags" filter: correct empty array detection
   - Multiple tags: correct OR logic

3. **Selectors**
   - `selectFilteredSegments()` with tag filters
   - `selectAvailableTags()` based on current segments

### Integration Tests

4. **Store integration**
   - Tag operations trigger history updates
   - Undo/redo with tags works correctly
   - Tag persistence in sessions survives reload

5. **UI & Keyboard**
   - Tag sidebar renders correctly
   - Tag assignment shortcuts (T+1...0) work
   - Filter toggles (single/double-click) update displayed segments
   - Context menu for exclude (NOT) filter works

---

## Future Extensions

1. **Tag suggestions**
   - AI recommends tags based on segment content (Phase 2+)
   - Autocomplete when naming new tags

2. **Custom tag colors**
   - Let users pick colors per tag (reuse speaker color picker pattern)
   - Phase 2+ scope

3. **Tag templates / Presets**
   - Save/load common tag sets per project
   - Quick-preset buttons in sidebar

4. **Hierarchical tags**
   - Prefix-based namespace: `OOC:INTRO`, `OOC:OUTRO`
   - Phase 3+ scope

5. **Batch tag operations**
   - UI for applying tags to ranges
   - Replace tag A with tag B across filtered segments

---

## Success Criteria

- âœ“ Tags assignable via T+1...0 (keyboard-first)
- âœ“ Tags filterable in sidebar (single-click = include, double-click/right-click = exclude/NOT)
- âœ“ Simple filter UI: no advanced modal needed
- âœ“ Tags persist across sessions
- âœ“ No regression in speaker filtering (additive only)
- âœ“ All tag operations undo/redo correctly
- âœ“ >80% test coverage on tag logic
- âœ“ UI consistent with speaker patterns
- âœ“ No memory/performance degradation with 100+ tags and complex filters


## Success Criteria

- âœ“ Tags assignable via Alt+1...0 (keyboard-first)
- âœ“ Tags filterable in sidebar (AND/NOT logic)
- âœ“ Tags persist across sessions
- âœ“ No regression in speaker filtering (additive only)
- âœ“ All tag operations undo/redo correctly
- âœ“ >80% test coverage on tag logic
- âœ“ UI consistent with speaker patterns
- âœ“ No memory/performance degradation with 100+ tags

